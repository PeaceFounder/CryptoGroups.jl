var documenterSearchIndex = {"docs":
[{"location":"curves/#Curves","page":"Curves","title":"Curves","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"Modules = [CryptoGroups.Curves]\nOrder = [:type, :function]","category":"page"},{"location":"curves/#CryptoGroups.Curves.AbstractPoint","page":"Curves","title":"CryptoGroups.Curves.AbstractPoint","text":"abstract type AbstractPoint end\n\nAn elliptic curve interface type. It is not expected that constructor of the group does instance validation and hence is unsafe. For safe use see ECPoint. The elliptic curve interface expects *, +, -, gx, gy and zero element to be implemented wheras the order and cofactor methods are added with the ECPoint subtype. In addition oncurve method is expected when used in combination with ECPoint.\n\nIt is expected that a point::AbstractPoint can be constructed back from it's coordinates and also from their octet representations:\n\nP = typeof(point)\nx, y = gx(point), gy(point)\npoint == P(x, y) == P(octet(x), octet(y))\n\nPoint compression is automatically supported through using octet on gx(point) and gy(point). For point decompression from a compressed octet the user must implement a constructor for the point type P(x::Vector{UInt8}, yÌƒ::Bool) or a direct method P(po::Vector{UInt8}). \n\n\n\n\n\n","category":"type"},{"location":"curves/#CryptoGroups.Curves.AffinePoint","page":"Curves","title":"CryptoGroups.Curves.AffinePoint","text":"struct AffinePoint{E <: EllipticCurve, T <: Field} <: AbstractPoint\n    x::T\n    y::T\nend\n\nAffine represantion of elliptic curve point. (Alternative represnations are Jacobi and projective coordinates which are currently unimplemented.) Operations *, + and - are unsafe and hence this type shall not be used outside ECPoint wrapping. See also AbstractPoint for supported methods.\n\n\n\n\n\n","category":"type"},{"location":"curves/#CryptoGroups.Curves.ECPoint","page":"Curves","title":"CryptoGroups.Curves.ECPoint","text":"struct ECPoint{P<:AbstractPoint, S} <: AbstractPoint\n    p::P\nend\n\nA wrapper type for elliptic curve points ensuring their safe use. The constructor validates that the point is on the curve and that it is not in cofactor subgroup. This check can be bypassed by specializing on validate method. Also adds safety  checks when doing a point summation in case when points are equal, inverse of each other and treats zero properly. \n\nIn addition to AbstractPoint methods *, +, -, gx, gy and zero, ECPoint implements order, cofactor\n\n\n\n\n\n","category":"type"},{"location":"curves/#Base.rem-Tuple{CryptoGroups.Curves.AbstractPoint, Integer}","page":"Curves","title":"Base.rem","text":"rem(p::AbstractPoint, q::T)::T where T <: Integer\n\nComputes a remainder of point x coordinate for a modulus q. The output is such that DSA and ECDSA of FIPS 186-4 standart can be combined into single imlementation\n\n\n\n\n\n","category":"method"},{"location":"curves/#Base.zero-Tuple{P} where P<:CryptoGroups.Curves.ECPoint","page":"Curves","title":"Base.zero","text":"zero(::Union{P, Type{P}}) where P <: AbstractPoint\n\nConstructs a zero element representation of a point type. Implementation of arithmetic can be delegated to ECPoint wrapper that treats the cases safely.\n\n\n\n\n\n","category":"method"},{"location":"curves/#CryptoGroups.Curves.cofactor-Union{Tuple{Type{ECPoint}}, Tuple{S}, Tuple{P}} where {P<:CryptoGroups.Curves.AbstractPoint, S}","page":"Curves","title":"CryptoGroups.Curves.cofactor","text":"cofactor(::Union{P, Type{P}}) where P <: ECPoint\n\nGets a cofactor of a point type or instance. \n\n\n\n\n\n","category":"method"},{"location":"curves/#CryptoGroups.Curves.gx-Tuple{CryptoGroups.Curves.ECPoint}","page":"Curves","title":"CryptoGroups.Curves.gx","text":"gx(p::AbstractPoint)::Field\n\nReturns x coordinate of a point instance. See also gy, value, octet.\n\n\n\n\n\n","category":"method"},{"location":"curves/#CryptoGroups.Curves.gy-Tuple{CryptoGroups.Curves.ECPoint}","page":"Curves","title":"CryptoGroups.Curves.gy","text":"gy(p::AbstractPoint)::Field\n\nReturns y coordinate of a point instance. See also gx, value, octet.\n\n\n\n\n\n","category":"method"},{"location":"curves/#CryptoGroups.Curves.oncurve-Tuple{CryptoGroups.Curves.ECPoint}","page":"Curves","title":"CryptoGroups.Curves.oncurve","text":"oncurve(p::AbstractPoint)::Bool\n\nChecks if a point coordinates satisfy elliptic curve equation.\n\n\n\n\n\n","category":"method"},{"location":"curves/#CryptoGroups.concretize_type-Union{Tuple{P}, Tuple{Type{ECPoint}, Integer, Integer}} where P<:CryptoGroups.Curves.AbstractPoint","page":"Curves","title":"CryptoGroups.concretize_type","text":"concretize_type(::Type{ECPoint{P}}, order::Integer, cofactor::Integer; name=nothing) where P <: AbstractPoint\n\nConstructs an ECPoint for a concrete point type P <: AbstractPoint with specified order and cofactor. The name is used for aliasing group parameters with @ECPoint{name} display semantics. \n\n\n\n\n\n","category":"method"},{"location":"curves/#CryptoGroups.order-Union{Tuple{Type{ECPoint}}, Tuple{S}, Tuple{P}} where {P<:CryptoGroups.Curves.AbstractPoint, S}","page":"Curves","title":"CryptoGroups.order","text":"order(::Union{P, Type{P}}) where P <: ECPoint\n\nGets an order of a point type or instance. \n\n\n\n\n\n","category":"method"},{"location":"generated/reed-solomon/","page":"Reed-Solomon EC","title":"Reed-Solomon EC","text":"EditURL = \"../../../examples/reed-solomon.jl\"","category":"page"},{"location":"generated/reed-solomon/#Reed-Solomon-Error-Correction","page":"Reed-Solomon EC","title":"Reed-Solomon Error Correction","text":"","category":"section"},{"location":"generated/reed-solomon/","page":"Reed-Solomon EC","title":"Reed-Solomon EC","text":"This Julia code demonstrates an implementation of the Reed-Solomon error correction algorithm, showcasing the power and flexibility of Julia's ecosystem in cryptographic applications. The implementation leverages the custom finite field arithmetic provided by CryptoGroups, specifically using a Galois Field GF(2^8) constructed from as an instance of generic polynomial extension field, and seamlessly integrates it with the external Polynomials package for polynomial operations.","category":"page"},{"location":"generated/reed-solomon/","page":"Reed-Solomon EC","title":"Reed-Solomon EC","text":"The code illustrates versatility of CryptoGroups package also for low-level finite field operations with high-level polynomial manipulations. It implements key components of the Reed-Solomon algorithm, including encoding, syndrome calculation, the Berlekamp-Massey algorithm for error locator polynomial generation, and error correction.","category":"page"},{"location":"generated/reed-solomon/","page":"Reed-Solomon EC","title":"Reed-Solomon EC","text":"HELP WANTED: Currently the implementation has bugs and can't even get correct error positions; To proceed one could write a tests for berklekamp_massey and when it works debug error_positions.","category":"page"},{"location":"generated/reed-solomon/","page":"Reed-Solomon EC","title":"Reed-Solomon EC","text":"using Test\nusing CryptoGroups.Fields\nusing Polynomials\n\nconst GF256 = @F2PB{X^8 + X^4 + X^3 + X + 1}\n\nroots(p) = GF256[i for i in 0:255 if iszero(p(GF256(i)))]\n\nfunction berklekamp_massey(syndromes::Vector{GF256})\n    B = Polynomial{GF256}([1])\n    C = Polynomial{GF256}([1])\n\n    L, m = 0, 1\n    for n in 1:length(syndromes)\n        # Adjust for zero-based indexing in Polynomial\n        d = syndromes[n] + sum(C[i-1] * syndromes[n - i + 1] for i in 1:L; init = zero(GF256))\n        if iszero(d)\n            m += 1\n        elseif 2*L <= n\n            T = C\n            # Use zero-based indexing for polynomial multiplication\n            C -= d * B * Polynomial{GF256}([0, 1])^(m-1)\n            L = n + 1 - L\n            B = T\n            m = 1\n        else\n            # Use zero-based indexing for polynomial multiplication\n            C -= d * B * Polynomial{GF256}([0, 1])^(m-1)\n            m += 1\n        end\n    end\n\n    return C\nend\n\nfunction rs_encode(message::Vector{UInt8}, g::Polynomial{GF256})\n\n    m = Polynomial{GF256}(message)\n\n    r_poly = m % g\n    r_octets = r_poly[:] .|> (x -> octet(x)[1])\n\n    return [message..., r_octets...]\nend\n\nfunction rs_decode(received::Vector{UInt8}, n::Int, k::Int, g::Polynomial{GF256})\n\n    received_poly = Polynomial{GF256}(received)\n\n    syndromes = [received_poly(r) for r in roots(g)]\n\n    if all(iszero(s) for s in syndromes)\n        return received[1:k] ## no errors detected\n    end\n\n    error_locator = berklekamp_massey(syndromes)\n\n    error_positions = [i for i in 1:n if iszero(error_locator(GF256(2)^i))]\n    # @show error_positions\n\n    error_evaluator = Polynomial{GF256}(syndromes) * error_locator % Polynomial{GF256}([zeros(Int, n - k)..., 1])\n\n    errors = zeros(GF256, n)\n\n    for i in error_positions\n        x = GF256(2) ^ (n - i)\n        y = error_evaluator(x) / derivative(error_locator)(x)\n        errors[i] = y\n    end\n\n    corrected = GF256[received...] .- errors\n\n    return corrected[1:k] .|> (x -> octet(x)[1])\nend\n\nn, k = 15, 11\ng = Polynomial{GF256}([1, 25, 6, 8, 14])\n\nmessage = rand(UInt8, k)\nencoded = rs_encode(message, g)\n\nerrors = zeros(UInt8, n)\nerrors[3] = rand(0:255)\nerrors[7] = rand(0:255)\nreceived = encoded + errors\n\ndecoded = rs_decode(received, n, k, g)\n\n# @test message == decoded","category":"page"},{"location":"generated/reed-solomon/","page":"Reed-Solomon EC","title":"Reed-Solomon EC","text":"","category":"page"},{"location":"generated/reed-solomon/","page":"Reed-Solomon EC","title":"Reed-Solomon EC","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/knowledge_proof/","page":"Proof of Knowledge","title":"Proof of Knowledge","text":"EditURL = \"../../../examples/knowledge_proof.jl\"","category":"page"},{"location":"generated/knowledge_proof/#Proof-of-Knowledge","page":"Proof of Knowledge","title":"Proof of Knowledge","text":"","category":"section"},{"location":"generated/knowledge_proof/","page":"Proof of Knowledge","title":"Proof of Knowledge","text":"This Julia code example demonstrates the implementation of a non-interactive zero-knowledge proof of knowledge (NIZKPoK) for the discrete logarithm problem. The code showcases how to prove knowledge of an exponent x for a given y = g^x without revealing the secret x itself, using group-agnostic methods.","category":"page"},{"location":"generated/knowledge_proof/","page":"Proof of Knowledge","title":"Proof of Knowledge","text":"The implementation provides both simple proof by disclosure and a more secure non-interactive zero-knowledge proof, along with their corresponding verification functions. By leveraging Julia's multiple dispatch and parametric types, the code is designed to work with any abstract group Group, making it flexible and applicable to various cryptographic settings. For demonstration we use P-192 elliptic curve group, but the core functions are written to be compatible with any group provided by CryptoGroups.","category":"page"},{"location":"generated/knowledge_proof/","page":"Proof of Knowledge","title":"Proof of Knowledge","text":"using Test\nusing CryptoGroups\nusing CryptoGroups.Utils: int2octet\nusing CryptoPRG: HashSpec, Verificatum\n\nverify(g::G, y::G, x::Integer) where G <: Group = g^x == y # proof by disclousure\n\n\nfunction challenge(g::G, y::G, R::G) where G <: Group\n\n    # the encoding is deserializable as `octet` returns fixed length output that depends on unerlying group\n    # nevertheless it is recommended to use a proper canoncial encoding for this purpose which we shall skip\n    prg = Verificatum.PRG(HashSpec(\"sha256\"), [octet(g)..., octet(y)..., octet(R)...])\n\n    return rand(prg, 2:order(G) - 1)\nend\n\nfunction prove(g::G, y::G, x::Integer) where G <: Group\n\n    # we can construct proof deterministically without relying on randomness source\n    prg = Verificatum.PRG(HashSpec(\"sha256\"), [octet(y)..., int2octet(x)...])\n\n    r = rand(prg, 2:order(G) - 1)\n\n    R = g^r\n\n    c = challenge(g, y, R)\n\n    s = (r + c * x) % order(G)\n\n    return R, s\nend\n\nfunction verify(g::G, y::G, R::G, s::Integer) where G <: Group\n\n    c = challenge(g, y, R)\n\n    return g^s == R * y^c\nend\n\n\ng = @ECGroup{P_192}()\n\nx = 21\ny = g^x\n\n@test verify(g, y, x)\n\nproof = prove(g, y, x)\n@test verify(g, y, proof...)","category":"page"},{"location":"generated/knowledge_proof/","page":"Proof of Knowledge","title":"Proof of Knowledge","text":"","category":"page"},{"location":"generated/knowledge_proof/","page":"Proof of Knowledge","title":"Proof of Knowledge","text":"This page was generated using Literate.jl.","category":"page"},{"location":"groups/#Groups","page":"Groups","title":"Groups","text":"","category":"section"},{"location":"groups/","page":"Groups","title":"Groups","text":"The CryptoGroups package provides a main API for working with cryptographic groups in a group-agnostic manner, supporting modular prime groups, elliptic curves over prime fields, and binary fields. This flexibility enables polymorphic implementations of standards like FIPS 186-4 digital signature algorithm to work seamlessly across different group types. Essential security checks, such as verifying point membership on elliptic curves or cofactor validation, are integrated into the constructors.","category":"page"},{"location":"groups/","page":"Groups","title":"Groups","text":"CryptoGroups encodes relevant group parameters as type parameter values, leveraging Julia's powerful type system to minimize the need for runtime assertions and ensure efficient memory use. This design allows for vector-like collections to be used without subtyping AbstractArray, resulting in a leaner and more predictable codebase. This also necessitates compiling every group, and are up to the user to decide which groups are needed for their applications.","category":"page"},{"location":"groups/","page":"Groups","title":"Groups","text":"Modules = [CryptoGroups]\nOrder = [:type, :function]","category":"page"},{"location":"groups/#CryptoGroups.ECGroup","page":"Groups","title":"CryptoGroups.ECGroup","text":"struct ECGroup{P<:ECPoint} <: Group\n    x::P\nend\n\nEllitpic curve group that maps ECPoint add and multiply to multiply and exponent semantics. The group can be instantiated from x, y coordinates ECGroup{P}(x, y) which are passed to corepsonding elliptic curve point constructor or via octet representation as specified in FIPS 186-4 standart. To construct the type use concretize_type or @ECGroup macro.\n\nExample\n\np192_spec = spec(:P_192)\nG = concretize_type(ECGroup, p192_spec)\n\n# A macro syntax\nG = @ECGroup{P_192}\n\nIf a group is instantiated from an existing specification then G() creates an instance of generator. A following ilustrates typical operations:\n\nG = @ECGroup{P_192}\ng = G()\ng^3 * g^5/g^2 == (g^3)^2 == g^6\ng^(order(G) - 1) * g == one(G)\none(G) * g == g\nG(octet(g)) == G(value(g)) == g\n\nSee also octet, value, concretize_type, spec\n\n\n\n\n\n","category":"type"},{"location":"groups/#CryptoGroups.Group","page":"Groups","title":"CryptoGroups.Group","text":"abstract type Group end\n\nA cyclic group interface type. It is expected that constructor of the group does instance validation and throws an ArgumentError if it can't be constructed. Identity element can be constructed with explicit argument allow_one=true and validation can be opted out with skip_validation=true argument for the constructor which can be useful for deserialization from a secure location locally. \n\nThe group element shall support construction from vector of bytes (octet) as well as octet method itself. In addition value method is expected that provides most simple representation useful for debugging purposes. Given g::Group a following constructor methods are supported:\n\nG = typeof(g)\ng == G(octet(g)) == G(value(g))\none(G) == G(octet(one(G)), allow_one=true)\n\nThe group must support order, *, ^, rem and identity element via one. For concrete implementations see PGroup and ECGroup. \n\n\n\n\n\n","category":"type"},{"location":"groups/#CryptoGroups.PGroup","page":"Groups","title":"CryptoGroups.PGroup","text":"struct PGroup{S} <: Group\n    g::BigInt\nend\n\nModulus prime group where S is a static type parameter encoding group properties. To instantiate a concrete type use a macor @PGroup or use concretize_type.\n\nExample\n\n# Directly passing type arguments\nG = concretize_type(PGroup, 23, 11) # where modulus is 23 and order is 11\n\n# Using a macro for user specification\nG = @PGroup{p = 23, q = 11}\n\n# Using existing specification\nmodp = spec(:RFC5114_2048_224)\nG = concretize_type(PGroup, modp)\n\n# Using a macro for existing specification\nG = @PGroup{RFC5114_2048_224}\n\nIf a group is instantiated from an existing specification then G() creates an instance of generator. A following ilustrates typical operations:\n\nG = @PGroup{p = 23, q = 11}\ng = G(2)\ng^3 * g^5/g^2 == (g^3)^2 == g^6\ng^(order(G) - 1) * g == one(G)\none(G) * g == g\nG(octet(g)) == G(value(g)) == g\n\nSee also octet, value, concretize_type, spec\n\n\n\n\n\n","category":"type"},{"location":"groups/#Base.:*-Union{Tuple{G}, Tuple{G, G}} where G<:CryptoGroups.ECGroup","page":"Groups","title":"Base.:*","text":"*(x::G, y::G)::G where G <: Group\n\nMultiplies two group elements.\n\n\n\n\n\n","category":"method"},{"location":"groups/#Base.:/-Union{Tuple{G}, Tuple{G, G}} where G<:Group","page":"Groups","title":"Base.:/","text":"/(x::G, y::G)::G where G <: Group\n\nConvinience method for x * inv(y)\n\n\n\n\n\n","category":"method"},{"location":"groups/#Base.:^-Union{Tuple{G}, Tuple{G, Integer}} where G<:CryptoGroups.ECGroup","page":"Groups","title":"Base.:^","text":"^(x::G, n::Integer)::G where G <: Group\n\nExponentiates the group element. In case mod(n, order(G)) == 0 throws an error in strict mode or shows a warning in relaxed mode.\n\nSee also isstrict and set_strict_mode\n\n\n\n\n\n","category":"method"},{"location":"groups/#Base.convert-Union{Tuple{P}, Tuple{Type{ECGroup}, Any}} where P<:CryptoGroups.Curves.ECPoint","page":"Groups","title":"Base.convert","text":"convert(::Type{G}, x; allow_one=false)::G where G <: Group\n\nConverts representation of x into a group element type G. The conversion is safe as the validation checks are performed within group constructors. In case identity element needs to be read into allow_one flag can be used to allow constructing identity elements. \n\n\n\n\n\n","category":"method"},{"location":"groups/#Base.inv-Tuple{G} where G<:Group","page":"Groups","title":"Base.inv","text":"inv(g::G)::G where G <: Group\n\nComputes inverse of the group element so that inv(g) * g == one(G)\n\n\n\n\n\n","category":"method"},{"location":"groups/#Base.one-Union{Tuple{ECGroup}, Tuple{P}} where P<:CryptoGroups.Curves.ECPoint","page":"Groups","title":"Base.one","text":"one(::Type{G}) where G\n\nConstruct an identity element of the group.\n\n\n\n\n\n","category":"method"},{"location":"groups/#Base.rem-Tuple{CryptoGroups.ECGroup, Integer}","page":"Groups","title":"Base.rem","text":"rem(x::ECGroup, q::T)::T where T <: Integer\n\nComputes remainder of the elliptic curve point\n\n\n\n\n\n","category":"method"},{"location":"groups/#Base.rem-Tuple{PGroup, Integer}","page":"Groups","title":"Base.rem","text":"rem(x::PGroup, q::T)::T where T <: Integer\n\nComputes remainder of a prime group integer value\n\n\n\n\n\n","category":"method"},{"location":"groups/#CryptoGroups.Fields.modulus-Union{Tuple{Type{PGroup}}, Tuple{S}} where S","page":"Groups","title":"CryptoGroups.Fields.modulus","text":"modulus(::Union{G, Type{G}})::BigInt where G <: PGroup\n\nModulus of a prime group. It is not recommended to depend on this method in the codebase as it destroys polymorphism.\n\n\n\n\n\n","category":"method"},{"location":"groups/#CryptoGroups.Fields.octet-Tuple{CryptoGroups.ECGroup}","page":"Groups","title":"CryptoGroups.Fields.octet","text":"octet(g::ECGroup; mode = :uncompressed|:hybrid|:compressed)::Vector{UInt8}\n\nConverts elliptic curve point to an octet representation as specified in FIPS 186-4 standart. The mode=:uncompressed|:hybrid|:compressed can be used to specify compression mode. \n\nSee also iscompressable\n\n\n\n\n\n","category":"method"},{"location":"groups/#CryptoGroups.Fields.octet-Tuple{PGroup}","page":"Groups","title":"CryptoGroups.Fields.octet","text":"octet(x::PGroup)::Vector{UInt8}\n\nConverts modulus prime group element into octet representation. A padding is added to match the length of modulus.\n\n\n\n\n\n","category":"method"},{"location":"groups/#CryptoGroups.concretize_type","page":"Groups","title":"CryptoGroups.concretize_type","text":"concretize_type(::Type{T}, args...) <: T where T\n\nConstructs a concrete subtype of union all or abstract type T. The arguments args are used to set concrtete values for type parameters of T, effectivelly concretizing a generic abstract type. The resulting type then can be instanitated by a value. \n\nSee also spec\n\n\n\n\n\n","category":"function"},{"location":"groups/#CryptoGroups.iscompressable-Tuple{Group}","page":"Groups","title":"CryptoGroups.iscompressable","text":"iscompressable(g::Group)::Bool\n\nReturns true if octet function accepts mode=:compressed as is groups based on eliptic curves. Currently for binary curves decompression is not implemented and hence this method returns false for them. \n\n\n\n\n\n","category":"method"},{"location":"groups/#CryptoGroups.order-Tuple{G} where G<:Group","page":"Groups","title":"CryptoGroups.order","text":"order(::Union{G, Type{G})::BigInt where G <: Group\n\nGet the order of the group\n\n\n\n\n\n","category":"method"},{"location":"groups/#CryptoGroups.spec","page":"Groups","title":"CryptoGroups.spec","text":"spec(::Union{G, Type{G}})::GroupSpec where G <: Group\n\nConstructs a specification of a group type or instance. It's general intended use is for debugging purposes and serves as an inverse to concretize_type method. If called with a group instance the the value of it is used for a generator for the group specification otherwise it is left empty.\n\nSee also concretize_type\n\n\n\n\n\n","category":"function"},{"location":"groups/#CryptoGroups.spec-Tuple{Symbol}","page":"Groups","title":"CryptoGroups.spec","text":"spec(name::Symbol)::GroupSpec\n\nGets a group specification from a provided canonical name of the group specification which are hardcoded into the library. \n\nExamples\n\n# NIST elliptic curve P-192 specification:\np192_spec = spec(:P_192)\nP192 = concretize_type(ECGroup, p192_spec)\n\n# Modular prime group specification\nmodp_spec = spec(:RFC5114_2048_224)\nMODP = concretize_type(PGroup, modp_spec)\n\nSee also concretize_type, @ECGroup, @PGroup\n\n\n\n\n\n","category":"method"},{"location":"groups/#CryptoGroups.value-Tuple{Group}","page":"Groups","title":"CryptoGroups.value","text":"value(g::Group)::Union{BigInt, Tuple{BigInt, BigInt}, Tuple{BitVector, BitVector}}\n\nConverts the group instance to the most simple representation. Generally intended for debugging purposes and for serialization one should use octet as it also ensures consistent padding. \n\nSee also octet, Curves.gx, Curves.gy\n\n\n\n\n\n","category":"method"},{"location":"groups/#CryptoGroups.verify_pgroup_membership-Tuple{BigInt, BigInt, BigInt}","page":"Groups","title":"CryptoGroups.verify_pgroup_membership","text":"Verifies membership in a prime-order group with optimizations for common cases.\n\n\n\n\n\n","category":"method"},{"location":"generated/dsa/","page":"Digital Signature Algorithm","title":"Digital Signature Algorithm","text":"EditURL = \"../../../examples/dsa.jl\"","category":"page"},{"location":"generated/dsa/#Digital-Signature-Algorithm","page":"Digital Signature Algorithm","title":"Digital Signature Algorithm","text":"","category":"section"},{"location":"generated/dsa/","page":"Digital Signature Algorithm","title":"Digital Signature Algorithm","text":"This Julia code demonstrates a group-agnostic implementation of the Digital Signature Algorithm (DSA), a widely used standard for message authentication. The implementation defines three key functions: keygen for key generation, sign for creating signatures, and verify for signature verification. While it omits the message hashing step for simplicity, the code adheres to FIPS 186-4 compliance, with safety checks integrated into the group element constructors.","category":"page"},{"location":"generated/dsa/","page":"Digital Signature Algorithm","title":"Digital Signature Algorithm","text":"The implementation is designed to work with any abstract group, showcasing Julia's multiple dispatch capabilities and allowing for flexibility across different cryptographic settings. To illustrate its functionality, the code includes a test case using the P-192 elliptic curve group. This example serves as a foundational demonstration of DSA and is foundation of CryptoSignatures.jl which offers extensive test suite and uses deterministic randomness for k generation.","category":"page"},{"location":"generated/dsa/","page":"Digital Signature Algorithm","title":"Digital Signature Algorithm","text":"using Test\nusing CryptoGroups\nusing CryptoGroups.Utils: @check\nusing Random: RandomDevice\n\nstruct DSA\n    r::Integer\n    s::Integer\nend\n\nfunction keygen(g::Group)\n\n    sk = rand(RandomDevice(), 2:order(g) - 1)\n    pk = octet(g^sk)\n\n    return sk, pk\nend\n\nfunction sign(e::Integer, g::Group, sk::Integer)\n\n    n = order(g)\n\n    k = rand(RandomDevice(), 2:order(g) - 1)\n\n    R = g^k\n\n    r = R % n\n    s = invmod(k, n) * (e + sk * r) % n\n\n    if r == 0 || s == 0\n        return sign(e, g, sk)\n    else\n        return DSA(r, s)\n    end\nend\n\nfunction verify(e::Integer, P::G, pk::Vector{UInt8}, sig::DSA) where {G <: Group}\n\n    n = order(G)\n\n    (; r, s) = sig\n\n    @check 1 < r < n - 1\n    @check 1 < s < n - 1\n\n    Q = G(pk)\n    c = invmod(s, n)\n\n    uâ‚ = e * c % n\n    uâ‚‚ = r * c % n\n\n    # Special cases must be handled by the developer\n    if uâ‚ == 0\n        W = Q ^ uâ‚‚\n    elseif uâ‚‚ == 0\n        W = P ^ uâ‚\n    else\n        W = P ^ uâ‚ * Q ^ uâ‚‚\n    end\n\n    Î½ = W % n\n\n    return Î½ == r\nend\n\n\ng = @ECGroup{P_192}()\nsk, pk = keygen(g)\n\nm = 42\nsig = sign(m, g, sk)\n@test verify(m, g, pk, sig)","category":"page"},{"location":"generated/dsa/","page":"Digital Signature Algorithm","title":"Digital Signature Algorithm","text":"","category":"page"},{"location":"generated/dsa/","page":"Digital Signature Algorithm","title":"Digital Signature Algorithm","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/elgamal/","page":"ElGamal Cryptosystem","title":"ElGamal Cryptosystem","text":"EditURL = \"../../../examples/elgamal.jl\"","category":"page"},{"location":"generated/elgamal/#ElGamal-Cryptosystem","page":"ElGamal Cryptosystem","title":"ElGamal Cryptosystem","text":"","category":"section"},{"location":"generated/elgamal/","page":"ElGamal Cryptosystem","title":"ElGamal Cryptosystem","text":"The ElGamal cryptosystem, as demonstrated in this Julia code example, is a fundamental component of many verifiable e-voting systems. This implementation showcases the core operations of the ElGamal encryption scheme, including key generation, encryption, and decryption and is implemented in a group agnostic way.","category":"page"},{"location":"generated/elgamal/","page":"ElGamal Cryptosystem","title":"ElGamal Cryptosystem","text":"The example illustrates both scalar and vector cases of ElGamal encryption. It defines an ElGamalRow struct to represent encrypted messages, and implements functions for encryption (enc) and decryption (dec). The code demonstrates how to encrypt multiple messages simultaneously and how to work with tuples of group elements as well as vectors. By using Julia's multiple dispatch capabilities, the implementation provides a flexible and type-safe approach to handling different input types. The test cases at the end of the file are made using P-192 elliptic curve group verify the correctness of the encryption and decryption operations for both single-row and multi-row scenarios.","category":"page"},{"location":"generated/elgamal/","page":"ElGamal Cryptosystem","title":"ElGamal Cryptosystem","text":"using Test\nusing CryptoGroups\n\nstruct ElGamalRow{G<:Group, N}\n    a::NTuple{N, G}\n    b::NTuple{N, G}\nend\n\nElGamalRow(m::NTuple{N, G}) where {N, G<:Group} = convert(ElGamalRow{G, N}, m)\nBase.convert(::Type{ElGamalRow{G, N}}, m::NTuple{N, G}) where {N, G <: Group} = ElGamalRow{G, N}(one.(m), m)\n\nenc(g::G, pk::G, e::ElGamalRow{G, N}, r::NTuple{N, <:Integer}) where {N, G <: Group} =\n    ElGamalRow(e.a .* g .^ r, e.b .* pk .^ r)\n\nenc(g::G, pk::G, m::NTuple{N, G}, r::NTuple{N, <:Integer}) where {N, G <: Group} = enc(g, pk, ElGamalRow(m), r)\n\ndec(e::ElGamalRow{G}, x::Integer) where G <: Group = e.b ./ e.a .^ x\n\n# A scalar example with 3 row elements\n\ng = @ECGroup{P_192}()\n\nx = 42\npk = g^x\n\nm = (g^2, g^3, g^4)\n\ncyphertexts = enc(g, pk, m, (4, 5, 6))\n\nplaintexts = dec(cyphertexts, x)\n\n@test plaintexts == m #\n\n# A vector case with 3 rows\n\nmvec = NTuple{3, typeof(g)}[\n    (g^2, g^3, g^4),\n    (g^4, g^7, g^8),\n    (g^3, g^9, g^2)\n]\n\nrvec = NTuple{3, Int}[\n    (4, 5, 6),\n    (4, 5, 6),\n    (4, 5, 6)\n]\n\ncyphertexts_vec = ((m, r) -> enc(g, pk, m, r)).(mvec, rvec)\n\nplaintexts_vec = dec.(cyphertexts_vec, x)\n\n@test plaintexts_vec == mvec","category":"page"},{"location":"generated/elgamal/","page":"ElGamal Cryptosystem","title":"ElGamal Cryptosystem","text":"","category":"page"},{"location":"generated/elgamal/","page":"ElGamal Cryptosystem","title":"ElGamal Cryptosystem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"fields/#Fields","page":"Fields","title":"Fields","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"Modules = [CryptoGroups.Fields]\nOrder = [:type, :function]","category":"page"},{"location":"fields/#CryptoGroups.Fields.BinaryField","page":"Fields","title":"CryptoGroups.Fields.BinaryField","text":"abstract type BinaryField <: Field end\n\nAn interface for a a binary field. Requires constructor for F(::BitVector) and convert(BitVector, ::BinaryField). Implements octet and coresponding constructor from octet. In addition implements a convinience constructor from integer by reinterpreting it first to bytes. \n\n\n\n\n\n","category":"type"},{"location":"fields/#CryptoGroups.Fields.F2GNB","page":"Fields","title":"CryptoGroups.Fields.F2GNB","text":"struct F2GNB{N, T} <: BinaryField\n    x::BitVector\nend\n\nBinary extension field in Gausian normal basis where N is a field degree and T is it's complexity type (an integer). Note that complexity type T is not an independent parameter but depends on N and may not exist. For generaration of complexity parameter see CryptoGroups.Specs.GNB constructor. Conversion between F2GNB and F2PB is not implemented, but is specified in ANSI X9.62 standard.\n\nExample\n\n# Direct type construction for degree 4\nF = F2GNB{4, 1}\n\n# Computing the type using `Specs.GNB`\n(; m, T) = Specs.GNB(4)\nF = F2GNB{m, T}\n\n# Instantiation\na = F2GNB{4, 3}(bin\"1000\")\nb = F2GNB{4, 3}(bin\"1101\")\na * b == F2GNB{4, 3}(bin\"0010\")\na + b == F2GNB{4, 3}(bin\"0101\")\n\n# Conversions\na == F(octet(a)) == F(value(a))\n\n\n\n\n\n","category":"type"},{"location":"fields/#CryptoGroups.Fields.F2PB","page":"Fields","title":"CryptoGroups.Fields.F2PB","text":"struct F2PB{R} <: BinaryField\n    x::BitVector\nend\n\nBinary extension field GF(2) with polynomial reducer that is encoded in a type parameter R. For type concretization a macro @F2PB is offered. The constructor from bitvector follows ANS X9.62 standart convention. \n\nExample\n\n# Concretizing binary field with bitvector\nF = @F2PB{bin\"10011\"} # equals to a polynomial f(X) = X^4 + X + 1\n\n# Passing polynomial directly\nF = @F2PB{X^4 + X + 1}\n\n# Instantiating a field element\na = F(bin\"1101\")\nb = F(bin\"1001\")\na * b = F(bin\"1111\")\na + b = F(bin\"0100\")\n\n# Conversions\nÎ± == F(octet(Î±)) == F(value(Î±))\n\n\n\n\n\n","category":"type"},{"location":"fields/#CryptoGroups.Fields.FP","page":"Fields","title":"CryptoGroups.Fields.FP","text":"struct FP{P} <: PrimeField\n    x::BigInt \nend\n\nModular prime field where P is a modulus. \n\nExample\n\n# If modulus is a bitstype\nx = FP{23}(2)\n\n# For BigInt modulus use a static method from Utils\np = BigInt(23)\ny = FP{static(p)}(2)\n\n\n\n\n\n","category":"type"},{"location":"fields/#CryptoGroups.Fields.Field","page":"Fields","title":"CryptoGroups.Fields.Field","text":"abstract type Field end\n\nAn abstract field interface. Requires *, ^, +, -, one, zero and order, octet, value. Implements inv. The Field type must supports a constructor for an element e::Field with properties:\n\ne == typeof(e)(octet(e)) == typeof(e)(value(e))\n\n\n\n\n\n","category":"type"},{"location":"fields/#CryptoGroups.Fields.PrimeField","page":"Fields","title":"CryptoGroups.Fields.PrimeField","text":"abstract type PrimeField <: Field end\n\nAn interface for a a modulus prime field. Requires constructor for F(::BigInt) and convert(BigInt, ::PrimeField) as well as modulus. It is recomended to subtype it for implementation of Mersenne primes.\n\n\n\n\n\n","category":"type"},{"location":"fields/#Base.:*-Union{Tuple{F}, Tuple{F, F}} where F<:CryptoGroups.Fields.PrimeField","page":"Fields","title":"Base.:*","text":"*(x::F, y::F)::F where F <: Field\n*(x::F, y::Integer)::F where F <: Field\n*(x::Integer, y::F)::F where F <: Field\n\nMultiplies two field elements. If element is and integer it is first converted to the field element before used to multiply.\n\n\n\n\n\n","category":"method"},{"location":"fields/#Base.:+-Union{Tuple{F}, Tuple{F, F}} where F<:CryptoGroups.Fields.PrimeField","page":"Fields","title":"Base.:+","text":"+(x::F, y::F)::F where F <: Field\n\nAdds two field elements.\n\n\n\n\n\n","category":"method"},{"location":"fields/#Base.:--Union{Tuple{F}, Tuple{F, F}} where F<:CryptoGroups.Fields.PrimeField","page":"Fields","title":"Base.:-","text":"-(x::F)::F where F <: Field\n\nConstructs a field element negative\n\n\n\n\n\n","category":"method"},{"location":"fields/#Base.:^-Union{Tuple{F}, Tuple{F, Integer}} where F<:CryptoGroups.Fields.PrimeField","page":"Fields","title":"Base.:^","text":"^(x::F, n::Integer) where F <: Field\n\nComputes an exponential of a field element.\n\n\n\n\n\n","category":"method"},{"location":"fields/#Base.rem-Tuple{CryptoGroups.Fields.BinaryField, Integer}","page":"Fields","title":"Base.rem","text":"rem(x::BinaryField, q::T)::T where T <: Integer\n\nConverts field value to an octet and then to integer from which remainder is computed. This is in accord with FIPS 186-4 standart for making ECDSA signatures over binary fields.\n\n\n\n\n\n","category":"method"},{"location":"fields/#Base.rem-Tuple{CryptoGroups.Fields.PrimeField, Integer}","page":"Fields","title":"Base.rem","text":"rem(x::PrimeField, q::T)::T where T <: Integer\n\nComputes a remainder of the field integer value.\n\n\n\n\n\n","category":"method"},{"location":"fields/#CryptoGroups.Fields.modulus","page":"Fields","title":"CryptoGroups.Fields.modulus","text":"modulus(::Union{F, Type{F}})::BigInt where F <: PrimeField\n\nGets a prime modulus of a \n\n\n\n\n\n","category":"function"},{"location":"fields/#CryptoGroups.Fields.octet-Tuple{CryptoGroups.Fields.BinaryField}","page":"Fields","title":"CryptoGroups.Fields.octet","text":"octet(x::Field)\n\nReturns a byte representation of a field element according to FIPS 186-4 standart.\n\n\n\n\n\n","category":"method"},{"location":"fields/#CryptoGroups.value","page":"Fields","title":"CryptoGroups.value","text":"value(x::PrimeField)::BigInt\n\nConverts a prime field element to an integer representation\n\n\n\n\n\n","category":"function"},{"location":"fields/#CryptoGroups.value-Tuple{CryptoGroups.Fields.BinaryField}","page":"Fields","title":"CryptoGroups.value","text":"value(x::BinaryField)::BitVector\n\nConverts a binary field elelement to a bitvector representation\n\n\n\n\n\n","category":"method"},{"location":"fields/#CryptoPRG.bitlength-Union{Tuple{Type{@F2PB}}, Tuple{R}} where R","page":"Fields","title":"CryptoPRG.bitlength","text":"bitlength(::Union{F, Type{F}})::Int where F <: Field\n\nBitlength for field type. For BinaryFields returns field degree wheras for PrimeField it is bitlength of modulus. \n\n\n\n\n\n","category":"method"},{"location":"utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"Modules = [CryptoGroups.Utils]\nOrder = [:type, :macro, :function]","category":"page"},{"location":"utils/#CryptoGroups.Utils.@bin_str-Tuple{Any}","page":"Utils","title":"CryptoGroups.Utils.@bin_str","text":"@bin_str(x)::BitVector\n\nConverts binary representation to BitVector:\n\nbin\"1010\" == BitVector([1, 0, 1, 0])\n\n\n\n\n\n","category":"macro"},{"location":"utils/#CryptoGroups.Utils.@check","page":"Utils","title":"CryptoGroups.Utils.@check","text":"@check(ex, msg = nothing)\n\nDrop in replacement for @assert macro as it can be eliminated in optimizations.\n\n\n\n\n\n","category":"macro"},{"location":"utils/#CryptoGroups.Utils.@hex_str-Tuple{Any}","page":"Utils","title":"CryptoGroups.Utils.@hex_str","text":"@hex_str(x)::Vector{UInt8}\n\nA convinience macro for converting a hex to byte vector:\n\nhex\"AAEF BBEC\" == UInt8[0xaa, 0xef, 0xbb, 0xec]\n\n\n\n\n\n","category":"macro"},{"location":"utils/#CryptoGroups.Utils.bits2octet-Tuple{BitVector}","page":"Utils","title":"CryptoGroups.Utils.bits2octet","text":"bits2octet(x::BitVector)::Vector{UInt8}\n\nConverts a bitvector to an octet.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CryptoGroups.Utils.dynamic-Tuple{Any}","page":"Utils","title":"CryptoGroups.Utils.dynamic","text":"dynamic(x)\n\nConverts static type to it's closest base type. Inverse of static method.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CryptoGroups.Utils.int2octet-Tuple{Integer, Int64}","page":"Utils","title":"CryptoGroups.Utils.int2octet","text":"int2octet(x::Integer, N::Int = bitlength(x))::Vector{UInt8}\n\nConverts integer x into an octet where optional N specifies number of allocated bits for the integer encoding. \n\n\n\n\n\n","category":"method"},{"location":"utils/#CryptoGroups.Utils.octet2bits-Tuple{Vector{UInt8}}","page":"Utils","title":"CryptoGroups.Utils.octet2bits","text":"octet2bits(x::Vector{UInt8}[, N::Int])::BitVector\n\nConverts an octet ot a bitvector with an optionally specified length N.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CryptoGroups.Utils.octet2int-Tuple{AbstractVector{UInt8}}","page":"Utils","title":"CryptoGroups.Utils.octet2int","text":"octet2int(x::Vector{UInt8})::BigInt\noctet2int(x::String)::BigInt\n\nConverts a binary octet to a BigInt. In case a string is passed it is treated as hexadecimal and is converted with hex2bytes. Equivalent in represeentation as parse(BigInt, bytes2hex(x), base=16).\n\n\n\n\n\n","category":"method"},{"location":"utils/#CryptoGroups.Utils.static-Tuple{BitVector}","page":"Utils","title":"CryptoGroups.Utils.static","text":"static(x)\nstatic(; kwargs...)\n\nIf x is not bitstype converts to a bitstype representation. Keyword arguments are used to construct a named tuple with every value being converted with static. Can be converted back to original type with dynamic method.\n\nExample\n\n# Single argument case\nx = BigInt(23)\nisbitstype(typeof(x)) == false\nisbitstype(typeof(static(x))) == true\nx == dynamic(static(x))\n\n# NamedTuple construction\n\nnt = static(; x = BigInt(23), y = 51, z = :name)\nisbittstype(typeof(nt)) == true\nnt.x == BigInt(23) # accessor methods do conversion with dynamic\ndynamic(nt) # ordinary named tuple with every value made dynamic\n\n\n\n\n\n","category":"method"},{"location":"generated/lagrange/","page":"Lagrange Polynomials","title":"Lagrange Polynomials","text":"EditURL = \"../../../examples/lagrange.jl\"","category":"page"},{"location":"generated/lagrange/#Lagrange-Interpolation","page":"Lagrange Polynomials","title":"Lagrange Interpolation","text":"","category":"section"},{"location":"generated/lagrange/","page":"Lagrange Polynomials","title":"Lagrange Polynomials","text":"This Julia code demonstrates the implementation of Lagrange interpolation over a modular field, a crucial component in cryptographic schemes such as Shamir's Secret Sharing. The implementation showcases the flexibility and composability of Julia's ecosystem by seamlessly integrating the external Polynomials package with the custom modular field arithmetic provided by CryptoGroups.","category":"page"},{"location":"generated/lagrange/","page":"Lagrange Polynomials","title":"Lagrange Polynomials","text":"CryptoGroups handles the finite field arithmetic, while Polynomials manages the polynomial operations, without creating a direct dependency between the two. The result is a concise yet powerful implementation that can be easily adapted for various cryptographic applications. The example includes a test case that reconstructs a secret (the constant term of the polynomial) using Lagrange interpolation, illustrating its practical application in secret sharing schemes.","category":"page"},{"location":"generated/lagrange/","page":"Lagrange Polynomials","title":"Lagrange Polynomials","text":"using Test\nusing CryptoGroups.Fields\nusing Polynomials\n\nfunction lagrange_interpolation(x::Vector{T}, y::Vector{T}) where T\n    n = length(x)\n    result = Polynomial{T}([0])\n\n    for i in 1:n\n        term = Polynomial{T}([1])\n        for j in 1:n\n            if i != j\n                term *= Polynomial{T}([-x[j], 1]) / (x[i] - x[j])\n            end\n        end\n        result += y[i] * term\n    end\n\n    return result\nend\n\np = 23\nsecret = 3\n\npoly = Polynomial{FP{p}}([secret, 5, 2, 5])\n\nx = FP{p}[2, 4, 6, 8]\ny = poly.(x)\n\ninterp_poly = lagrange_interpolation(x, y)\n\n@test value(interp_poly(0)) == secret","category":"page"},{"location":"generated/lagrange/","page":"Lagrange Polynomials","title":"Lagrange Polynomials","text":"","category":"page"},{"location":"generated/lagrange/","page":"Lagrange Polynomials","title":"Lagrange Polynomials","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/kem/","page":"Key Encapsulation Mechanism","title":"Key Encapsulation Mechanism","text":"EditURL = \"../../../examples/kem.jl\"","category":"page"},{"location":"generated/kem/#Key-Encpsulation-Mechanism","page":"Key Encapsulation Mechanism","title":"Key Encpsulation Mechanism","text":"","category":"section"},{"location":"generated/kem/","page":"Key Encapsulation Mechanism","title":"Key Encapsulation Mechanism","text":"A Key Encapsulation Mechanims allows (KEM) is a widelly used techinque to assymetrically encrypt messages that only recepient with knowledge of it's secret key can decrypt. In it's essence it is a Diffie-Hellman key computation where the secret key is used to encrypt the message with a symmetric cypher. With CryptoGroups we can write the key computation in a group agnostic way by defining three functions:","category":"page"},{"location":"generated/kem/","page":"Key Encapsulation Mechanism","title":"Key Encapsulation Mechanism","text":"keygen: Generates a private-public key pair;\nencap: Encapsulates a shared secret key using the recipient's public key;\ndecap: Decapsulates the shared secret key using the recipient's private key.","category":"page"},{"location":"generated/kem/","page":"Key Encapsulation Mechanism","title":"Key Encapsulation Mechanism","text":"At the end of the code we demonstrate how the code can be used with P-192 curve and verify that the derived keys match. Notice that methods are defined in a group agnostic way. Together with symmetric primitives defined in Nettle.jl this can be an excellent starting point for implementing some assymetric encryption specifications in Julia.","category":"page"},{"location":"generated/kem/","page":"Key Encapsulation Mechanism","title":"Key Encapsulation Mechanism","text":"using Test\nusing CryptoGroups\nusing Random: RandomDevice\n\nfunction keygen(g::Group)\n\n    sk = rand(RandomDevice(), 2:order(g) - 1)\n    pk = octet(g^sk)\n\n    return sk, pk\nend\n\nfunction encap(g::G, pk::Vector{UInt8}) where G <: Group\n\n    y = G(pk)\n\n    r = rand(RandomDevice(), 2:order(G) - 1)\n    t = y^r\n    k = octet(t) # further hashing recomended\n    c = g^r\n\n    return k, c\nend\n\nfunction decap(c::Group, sk::Integer)\n\n    t = c^sk\n    k = octet(t)\n\n    return k\nend\n\n\ng = @ECGroup{P_192}()\nsk, pk = keygen(g)\n\nk, c = encap(g, pk)\n\nkâ€² = decap(c, sk)\n\n@test kâ€² == k","category":"page"},{"location":"generated/kem/","page":"Key Encapsulation Mechanism","title":"Key Encapsulation Mechanism","text":"","category":"page"},{"location":"generated/kem/","page":"Key Encapsulation Mechanism","title":"Key Encapsulation Mechanism","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/external_fields/","page":"Field Subtyping","title":"Field Subtyping","text":"EditURL = \"../../../examples/external_fields.jl\"","category":"page"},{"location":"generated/external_fields/#Field-Subtyping","page":"Field Subtyping","title":"Field Subtyping","text":"","category":"section"},{"location":"generated/external_fields/","page":"Field Subtyping","title":"Field Subtyping","text":"This example demonstrates the flexibility and extensibility of the CryptoGroups package, showcasing how custom field implementations can be seamlessly integrated with existing elliptic curve operations. Specifically, it illustrates how to wrap and use GaloisFields's binary extension field implementation within the CryptoGroups to do computations with elliptic curves.","category":"page"},{"location":"generated/external_fields/","page":"Field Subtyping","title":"Field Subtyping","text":"The modular approach of CryptoGroups allows users to integrate custom field implementations with elliptic curves easily. By defining a few key methods and ensuring proper subtyping, users can drop in their optimised field implementations - be it binary fields as shown here or Mersenne primes and test different optimisations with elliptic curves while allowing the use of existing implementations as reference. This design promotes the separation of concerns where one can focus on optimising fields, one new elliptic curve support or new arithmetic formulas like projective coordinates separately from each other.","category":"page"},{"location":"generated/external_fields/","page":"Field Subtyping","title":"Field Subtyping","text":"using Test\nusing CryptoGroups\nimport CryptoGroups: BinaryField, concretize_type, PB, bitlength\nimport GaloisFields: ExtensionField, GaloisField\n\nstruct GFâ‚‚{F <: ExtensionField} <: BinaryField\n    x::F\n\n    GFâ‚‚{F}(coeffs::NTuple{N, GaloisField(2)}) where {N, F <: ExtensionField} = new(F(coeffs))\n\n    function GFâ‚‚{F}(xrev::BitVector) where F <: ExtensionField\n        x = reverse(xrev)\n        ð”½â‚‚ = GaloisField(2)\n        coeffs = Tuple(ð”½â‚‚(i) for i in x) # May need a reverse\n        return GFâ‚‚{F}(coeffs)\n    end\n\n    GFâ‚‚{F}(x::F) where F <: ExtensionField = new{F}(x)\n    GFâ‚‚(x::F) where F <: ExtensionField = new{F}(x)\n\n    function GFâ‚‚(f::BitVector)\n        F, x = GaloisField(2, :x=>f)\n        return GFâ‚‚{F}\n    end\n\n    GFâ‚‚(poly::Vector{Int}) = GFâ‚‚(BitVector(i in poly for i in 0:maximum(poly)))\nend\n\nbitlength(::Type{F}) where F <: ExtensionField = length(F.parameters[4]) - 1\nbitlength(::Type{GFâ‚‚{F}}) where F <: ExtensionField = bitlength(F)\n\nconcretize_type(::Type{GFâ‚‚}, basis::PB) = GFâ‚‚(basis.f)\n\nBase.convert(::Type{F}, a::BitVector) where F <: GFâ‚‚ = F(a)\nBase.convert(::Type{BitVector}, a::GFâ‚‚) = reverse(BitVector(i.n for i in a.x.coeffs))\n\nBase.:+(a::F, b::F) where F <: GFâ‚‚ = F(a.x + b.x)\nBase.:*(a::F, b::F) where F <: GFâ‚‚ = F(a.x * b.x)\n\nBase.inv(a::F) where F <: GFâ‚‚ = F(inv(a.x))\n\nBase.zero(::Type{GFâ‚‚{F}}) where F <: ExtensionField = GFâ‚‚(zero(F))\nBase.one(::Type{GFâ‚‚{F}}) where F <: ExtensionField = GFâ‚‚(one(F))\n\n\n########################## This one we can test easally as follows ##################\n\nimport CryptoGroups.Curves: oncurve, order, AffinePoint, ECPoint, BinaryCurve\nimport CryptoGroups: generator\nimport CryptoGroups.Specs: Curve_B_163_PB, Curve_K_163_PB\n\nlet\n    B_163v3 = concretize_type(AffinePoint{BinaryCurve, GFâ‚‚}, Curve_B_163_PB)\n\n    g = B_163v3(generator(Curve_B_163_PB))\n    q = order(Curve_B_163_PB)\n\n    @test oncurve(g)\n    @test oncurve(g*3)\n    @test g * (q + 1) == g\nend\n\nlet\n    K_163v3 = concretize_type(ECPoint{AffinePoint{BinaryCurve, GFâ‚‚}}, Curve_K_163_PB)\n\n    g = K_163v3(generator(Curve_K_163_PB))\n    q = order(Curve_K_163_PB)\n\n    @test oncurve(g)\n    @test oncurve(g*3)\n    @test g * (q + 1) == g\nend","category":"page"},{"location":"generated/external_fields/","page":"Field Subtyping","title":"Field Subtyping","text":"","category":"page"},{"location":"generated/external_fields/","page":"Field Subtyping","title":"Field Subtyping","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"EditURL = \"../../README.md\"","category":"page"},{"location":"#CryptoGroups.jl","page":"Overview","title":"CryptoGroups.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"(Image: codecov) (Image: )","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"CryptoGroups is a Julia package that provides a versatile and type-safe implementation of cryptographic groups. It offers a unified interface for working with various types of groups, including modular prime groups and elliptic curves over prime and binary fields. Suitable for both academic and aspiring production environments, CryptoGroups has been rigorously tested and refined through its implementation in real-world projects such as CryptoSignatures and ShuffleProofs, ensuring a robust and versatile cryptographic toolkit.","category":"page"},{"location":"#Key-Features","page":"Overview","title":"Key Features","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Group-Agnostic API: CryptoGroups allows for polymorphic implementations of cryptographic standards, such as the FIPS 186-4 digital signature algorithm, that work seamlessly across different group types.\nType Safety: The package leverages Julia's powerful type system, encoding relevant group parameters as type parameter values. This design minimizes the need for runtime assertions and ensures efficient memory use.\nComprehensive Group Support: CryptoGroups supports a wide range of cryptographic groups, including:\nModular prime groups\nElliptic curves over prime fields\nElliptic curves over binary fields\nAll curves specified in FIPS 186-4, including Weierstrass curves, Koblitz curves, and Pseudorandom curves:\nCurve Type Curves\nWeierstrass Curves P_192 (prime192v1, secp192r1), P_224, P_256 (prime256v1, secp256r1), P_384, P_521\nKoblitz Curves K_163, K_233, K_283, K_409, K_571\nPseudorandom Curves B_163, B_233, B_288, B_409, B_571\nNote: Koblitz and Pseudorandom curves can be instantiated in polynomial or Gaussian normal basis (default) fields. Currently, Koblitz curves are mapped to generic binary curves, so there are no performance benefits specific to Koblitz curves in the current implementation. In future support for Montgomery and Edwards curves as specified in FIPS 186-5 may be added. \nSafety-First Approach: Essential security checks, such as verifying point membership on elliptic curves or cofactor validation, are integrated into the constructors. Special cases in arithmetic are treated properly.\nEasy-to-Use Interface: CryptoGroups provides macro constructors for quick experimentation and type aliasing, making it ideal for both beginners and experienced cryptographers.","category":"page"},{"location":"#Main-Components","page":"Overview","title":"Main Components","text":"","category":"section"},{"location":"#Group-Types","page":"Overview","title":"Group Types","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Group: An abstract type representing a cyclic group.\nPGroup: Represents modular prime groups (instantiated with @PGRoup).\nECGroup: Represents elliptic curve groups (instantiated with @ECGRoup).","category":"page"},{"location":"#Key-Methods","page":"Overview","title":"Key Methods","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"order: Get the order of the group\noctet: Convert group elements to octet representation\nvalue: Convert group elements to their simplest representation\n*, /, ^: Perform group operations (multiplication, division, exponentiation)\ninv: Compute the inverse of a group element\none: Construct the identity element of the group","category":"page"},{"location":"#Utility-Functions","page":"Overview","title":"Utility Functions","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"concretize_type: Construct concrete subtypes of abstract group types\nspec: Get or construct group specifications\niscompressable: Check if a group element can be compressed in octet representation","category":"page"},{"location":"#Usage-Examples","page":"Overview","title":"Usage Examples","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Creating a modular prime group:\nG = @PGroup{p = 23, q = 11}\ng = G(2)\nCreating an elliptic curve group:\nG = @ECGroup{P_192}\ng = G() # uses generator from specification\nPerforming group operations:\ng^3 * g^5 / g^2 == (g^3)^2 == g^6\ng^(order(G) - 1) * g == one(G)\nSerializing and deserializing:\ng == G(octet(g)) == G(value(g))","category":"page"},{"location":"#Safety-Guarantees","page":"Overview","title":"Safety Guarantees","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"While no cryptographic system can guarantee absolute security, CryptoGroups implements the following safety features:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Group element arithmetics is possible only with the same types of groups and throws MethodError when that is violated. For instance, @ECGroup{P_192}() * @ECGroup{P_256}() throws an error;\nGroup elements are validated during construction, throwing ArgumentError for invalid inputs;\nModular prime group elements are checked to belong in prime group via g^q = 1 or with an efficient jaocbi(g, p) = 1 for quadratic residue groups;\nElliptic curve points are checked for curve equation satisfaction and cofactor validation;\nThe package implements checks to prevent issues with special cases in point addition formulas;\nExponentiation with k rm mod q = 0 shows warning or throws an error in a strict mode.","category":"page"},{"location":"#Limitations-and-Future-Work","page":"Overview","title":"Limitations and Future Work","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"CryptoGroups prioritizes type safety and flexibility in its implementation of cryptographic groups. However, this focus comes with some trade-offs in terms of performance, which in turn can have implications for security in certain scenarios.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The current implementation of CryptoGroups has several areas where performance optimizations are yet to be implemented:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The package doesn't use projective coordinates for elliptic curve arithmetics;\nLacks special treatment for Koblitz curves;\nDoesn't implement Mersenne primes when available over generic prime fields;\nBinary field operations, the current implementation is suboptimal and doesn't take advantage of hardware-provided carryless operations.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"These limitations result in significantly slower performance compared to state-of-the-art implementations. Preliminary estimates suggest that operations on prime curves in CryptoGroups are about 100 times slower than optimized libraries like OpenSSL, while binary curves may be up to 1000 times slower.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"These performance limitations can potentially lead to security risks in certain contexts. The most immediate concern is the increased vulnerability to Denial of Service (DoS) attacks. Since computations take longer to complete, systems using CryptoGroups for cryptographic operations could be more easily overwhelmed by a flood of requests. Additionally, the current arithmetic operations are not side-channel resistant, which could pose a risk if an adversary is able to monitor the machine performing the group operations.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"For scenarios where only remote adversaries are a concern, the side-channel risk can be mitigated via time-padding. Set a fixed computation time based on benchmarks, add sleep periods to reach this time, and reject results if the computation exceeds the set time due to system overload. However, this approach doesn't address the fundamental performance limitations and may not be suitable for all use cases.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Looking ahead, there are several areas where CryptoGroups could be improved to address these performance and security concerns. Future work should focus on implementing projective coordinates for elliptic curves, optimizing binary field operations using hardware-specific instructions, and developing constant-time arithmetic operations to improve side-channel resistance. Additionally, conducting thorough security audits and expanding test coverage will be crucial to identify and address any overlooked vulnerabilities.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Despite these limitations, CryptoGroups provides a solid foundation for cryptographic operations in Julia. Its type-safe design and comprehensive group support make it an excellent tool for educational purposes, allowing users to experiment with and learn about various cryptographic groups. For production use, while CryptoGroups can be deployed, users should carefully consider the performance implications and implement necessary security measures. With appropriate caution and mitigation strategies, CryptoGroups can be a valuable component in cryptographic applications, particularly in scenarios where its strengths in type safety and flexibility outweigh the performance limitations.","category":"page"},{"location":"#References","page":"Overview","title":"References","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"elliptic-curve library in Haskell that shares similar goals regarding type safety\nRFC2409 and RFC5114 for modular prime group constants\nSafeCurves on addition checks for Weierstrass curves\nFIPS 186-4 and FIPS 186-5\nNIST SP 800-186\nANSI X9.142 and in unpaywalled form here\nCryptoSignatures.jl FIPS 186-4 digital signature algorithm implemetation\nShuffleProofs.jl Verificatum compatable ElGamal proof of shuffle implementation","category":"page"}]
}
